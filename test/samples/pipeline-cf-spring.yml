{{^isVSI}}
---
stages:
- name: Build Stage
  inputs:
  - type: git
    branch: master
    service: ${REPO}
  triggers:
  - type: commit
  {{#isKube}}
  properties:
  - name: CHART_NAME
    value: ${CHART_NAME}
    type: text
  - name: KUBECTL_VERSION
    value: $(wget -qO- https://github.com/kubernetes/kubernetes/releases | sed -n '/Latest release<\/a>/,$p' | grep -oE 'v[0-9]+\.[0-9]+\.[0-9]+' |head -1)
    type: text
  - name: HELM_VERSION
    value: $(wget -qO- https://github.com/kubernetes/helm/releases | sed -n '/Latest release<\/a>/,$p' | grep -oE 'v[0-9]+\.[0-9]+\.[0-9]+' |head -1)
    type: text
  - name: KUBECTL_DOWNLOAD_URL
    value: https://storage.googleapis.com/kubernetes-release/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl
    type: text
  - name: HELM_DOWNLOAD_URL
    value: https://kubernetes-helm.storage.googleapis.com/helm-${HELM_VERSION}-linux-amd64.tar.gz
    type: text
  {{/isKube}}
  jobs:
  - name: Build
    type: builder
    {{^isKube}}
    build_type: shell
    script: |
      #!/bin/bash
      export JAVA_HOME=$JAVA8_HOME
      gradle build

      if  [[ -f post_build.sh ]]; then
        chmod +x post_build.sh;
        echo "executing the post_build script";
        sh post_build.sh;
      else
        echo "the post_build script does not exist";
      fi
    {{/isKube}}
    {{#isKube}}
    build_type: cr
    artifact_dir: ''
    target:
      region_id: ${REGION_ID}
      api_key: ${API_KEY}
    namespace: ${REGISTRY_NAMESPACE}
    image_name: ${CHART_NAME}
    script: |-
      #!/bin/bash
      echo "Doing Java build"
      echo "DevOps sets LOG_DIR env var, which is used during Java build to check if server started, so unsetting"
      echo "LOG_DIR: ${LOG_DIR}"
      LOG_DIR_TEMP=$LOG_DIR
      unset LOG_DIR
      echo "LOG_DIR has been unset: ${LOG_DIR}"

      export JAVA_HOME=$JAVA8_HOME
      gradle build

      echo "Java build finished, setting LOG_DIR back to original"
      LOG_DIR=$LOG_DIR_TEMP
      echo "LOG_DIR: ${LOG_DIR}"

      mkdir downloads
      PATH="downloads:$PATH"

      if [ "$(echo "$(helm version -c)" | grep $HELM_VERSION)" == "" ]; then
        echo "Downloading helm v$HELM_VERSION"
        curl -SsL "$HELM_DOWNLOAD_URL" -o "helm-${HELM_VERSION}-linux-amd64.tar.gz"
        tar -zxvf helm-${HELM_VERSION}-linux-amd64.tar.gz
        chmod 700 linux-amd64/helm
        mv linux-amd64/helm downloads/helm
        chmod +x downloads/helm
      fi

      if [ "$(echo "$(kubectl version --client)" | grep $KUBECTL_VERSION)" == "" ]; then
        echo "Downloading kubectl v$KUBECTL_VERSION"
        curl -LO "$KUBECTL_DOWNLOAD_URL"
        chmod +x kubectl
        mv kubectl downloads/kubectl
      fi

      echo "helm version"
      helm version -c
      echo "kubectl version"
      kubectl version --client

      echo "source the container_build script to run in current shell"
      SCRIPTS_DIR=.bluemix/scripts # SCRIPTS_DIR is used in container_build.sh
      source ${SCRIPTS_DIR}/container_build.sh

      if  [[ -f post_build.sh ]]; then
        chmod +x post_build.sh;
        echo "executing the post_build script";
        sh post_build.sh;
      else
        echo "the post_build script does not exist";
      fi
    {{/isKube}}
- name: Deploy Stage
  inputs:
  - type: job
    stage: Build Stage
    job: Build
  {{#isKube}}
  properties:
  - name: buildProperties
    value: build.properties
    type: file
  - name: CHART_NAME
    value: ${CHART_NAME}
    type: text
  - name: CLUSTER_NAMESPACE
    value: ${CLUSTER_NAMESPACE}
    type: text
  - name: IMAGE_REGISTRY_TOKEN
    value: ${IMAGE_REGISTRY_TOKEN}
    type: text
  {{/isKube}}
  triggers:
  - type: stage
  jobs:
  - name: Deploy
    type: deployer
    target:
      {{#isCFEE}}
      cfee_env: ${CFEE_ENV}
      cfee_host: ${CFEE_HOST}
      organization: ${CF_ORGANIZATION}
      space: ${CF_SPACE}
      {{/isCFEE}}
      {{#isCF}}
      region_id: ${REGION_ID}
      organization: ${CF_ORGANIZATION}
      space: ${CF_SPACE}
      {{/isCF}}
      application: ${CF_APP}
      api_key: ${API_KEY}
      {{#isKube}}
      region_id: ${REGION_ID}
      kubernetes_cluster: ${KUBE_CLUSTER_NAME}
    script: |-
      #!/bin/bash
      export PATH="downloads:$PATH"
      echo "source the kube_deploy script to run in current shell"
      source .bluemix/scripts/kube_deploy.sh
      echo "export IP_ADDR=${IP_ADDR}" >> kube_vars.sh
      echo "export PORT=${PORT}" >> kube_vars.sh
      {{/isKube}}
    {{#isCF}}
    script: |-
      #!/bin/bash
      cf push "${CF_APP}" -p target/testArtifact-id-0.0.1-SNAPSHOT.jar --hostname "${CF_HOSTNAME}" -d "${CF_DOMAIN}"
      # cf logs "${CF_APP}" --recent
    {{/isCF}}
    {{#isCFEE}}
    script: |-
      #!/bin/bash
      cf push "${CF_APP}" -p target/testArtifact-id-0.0.1-SNAPSHOT.jar --hostname "${CF_HOSTNAME}" -d "${CF_DOMAIN}"
      # cf logs "${CF_APP}" --recent
    {{/isCFEE}}
- name: Health Stage
  inputs:
  - type: job
    stage: Build Stage
    job: Build
  triggers:
  - type: stage
  permission:
    execute: TOOLCHAIN_ADMINS
  {{#isKube}}
  properties:
  - name: CLUSTER_NAMESPACE
    value: ${CLUSTER_NAMESPACE}
    type: text
  - name: IMAGE_REGISTRY_TOKEN
    value: ${IMAGE_REGISTRY_TOKEN}
    type: text
  - name: buildProperties
    value: build.properties
    type: file
  jobs:
  - name: Deploy
    type: deployer
    deploy_type: kubernetes
    target:
      region_id: ${REGION_ID}
      api_key: ${API_KEY}
      kubernetes_cluster: ${KUBE_CLUSTER_NAME}
    script: |-
      export PATH="downloads:$PATH"
      IP_ADDR=$(ibmcloud cs workers ${PIPELINE_KUBERNETES_CLUSTER_NAME} | grep normal | head -n 1 | awk '{ print $2 }')
      if [[ "${CLUSTER_NAMESPACE}" != "default" ]]; then
        RELEASE_NAME="${CLUSTER_NAMESPACE}-${IMAGE_NAME}"
      else
        RELEASE_NAME=${IMAGE_NAME}
      fi
      echo "RELEASE_NAME: $RELEASE_NAME"

      PORT=$(kubectl get services --namespace ${CLUSTER_NAMESPACE} | grep ${RELEASE_NAME} | sed 's/[^:]*:\([0-9]*\).*/\1/g')
      if [ "$(curl -Is http://$IP_ADDR:$PORT/health --connect-timeout 3 --max-time 5 --retry 2 --retry-max-time 30 | head -n 1 | grep 200)" != "" ]; then
        echo "Successfully reached health endpoint"
        echo "====================================================================="
      else
        echo "Could not reach health endpoint: http://$IP_ADDR:$PORT/health"
        exit 1;
      fi;
  {{/isKube}}
  {{#isCF}}
  jobs:
  - name: Test
    type: tester
    script: |-
      #!/bin/sh
      apk add --no-cache curl
      if [ "$(curl -Is http://myapp.ng.bluemix.net/health  --connect-timeout 3 --max-time 5 --retry 3 --retry-max-time 30 | head -n 1 | grep 200)" != "" ]; then
        echo "Successfully reached health endpoint"
        echo "====================================================================="
      else
        echo "Could not reach health endpoint: http://myapp.ng.bluemix.net/health"
        exit 1;
      fi;
    test_type: customimage
    docker_image: alpine
  {{/isCF}}
  {{#isCFEE}}
  jobs:
  - name: Test
    type: tester
    script: |-
      #!/bin/sh
      apk add --no-cache curl
      if [ "$(curl -Is http://myapp.ng.bluemix.net/health  --connect-timeout 3 --max-time 5 --retry 3 --retry-max-time 30 | head -n 1 | grep 200)" != "" ]; then
        echo "Successfully reached health endpoint"
        echo "====================================================================="
      else
        echo "Could not reach health endpoint: http://myapp.ng.bluemix.net/health"
        exit 1;
      fi;
    test_type: customimage
    docker_image: alpine
  {{/isCFEE}}
{{/isVSI}}
{{#isVSI}}
  ---
stages:
- name: Build Preparation Stage
  inputs:
  - type: git
    branch: master
    service: ${REPO}
  properties:
  - name: VI_INSTANCE_NAME
    value: my-application
    type: text
  - name: PUBLIC_KEY
    value: "${PUBLIC_KEY}"
    type: secure
  - name: PRIVATE_KEY
    value: "${PRIVATE_KEY}"
    type: secure
  - name: TF_VAR_ibm_sl_username
    value: "${TF_VAR_ibm_sl_username}"
    type: text
  - name: TF_VAR_ibm_sl_api_key
    value: "${TF_VAR_ibm_sl_api_key}"
    type: secure
  - name: TF_VAR_ibm_cloud_api_key
    value: "${API_KEY}"
    type: secure
  - name: GIT_USER
    value: "${GITLAB_USERNAME}"
    type: text
  - name: GIT_PASSWORD
    value: "${GITLAB_ACCESS_TOKEN}"
    type: secure
  jobs:
  - name: Validate
    type: builder
    artifact_dir: ''
    build_type: shell
    script: |
      #!/bin/bash
      set -eo pipefail
      bash terraform/scripts/validate.sh
  - name: Set Keys
    type: builder
    artifact_dir: ''
    build_type: shell
    script: |
      #!/bin/bash
      set -eo pipefail
      echo "${PUBLIC_KEY}" > terraform/publickey.txt
      echo "${TF_VAR_ibm_sl_api_key}" > terraform/slkey.txt
      echo "${TF_VAR_ibm_sl_username}" > terraform/slusername.txt
      echo "${TF_VAR_ibm_cloud_api_key}" > terraform/cloudkey.txt
      echo "${VI_INSTANCE_NAME}" > terraform/instancename.txt
      echo "${PRIVATE_KEY}" > terraform/ssh_private_key && chmod 400 terraform/ssh_private_key
      echo "${GIT_URL}" > terraform/giturl.txt
      if [ ! -z "${GIT_USER}" ]; then echo $GIT_USER > terraform/gituser.txt; fi
      if [ ! -z "${GIT_PASSWORD}" ]; then echo $GIT_PASSWORD > terraform/gitpassword.txt; fi
- name: Build Stage
  inputs:
  - type: job
    stage: Build Preparation Stage
    job: Set Keys
  triggers:
  - type: stage
  jobs:
  - name: Build
    type: builder
    artifact_dir: ''
    build_type: customimage
    script: |
      # download `ibmcloud` cli and `dev` plugin
      curl -fsSL https://clis.ng.bluemix.net/install/linux | sh
      ibmcloud plugin install dev
      
      # log in and set ibmcloud cli target
      ibmcloud api https://api.ng.bluemix.net
      export TF_VAR_ibm_cloud_api_key=$(cat terraform/cloudkey.txt)
      ibmcloud login --apikey $TF_VAR_ibm_cloud_api_key
      ibmcloud target --cf-api https://api.ng.bluemix.net 
      
      # Fetch CF org and space for the current account 
      # These are not used during deployment, but must be set to use the `dev` cli.  
      # Any value will work, so this fetches the first ones encountered
      export ORG=$(ibmcloud account orgs | awk 'NR==6' | awk '{split($0,a," "); print a[1]}')
      export SPACE=$(ibmcloud account spaces -o $ORG | awk 'NR==5')
      ibmcloud target --cf-api https://api.ng.bluemix.net -o $ORG -s $SPACE
      
      # fetch credentials for the app instance
      ibmcloud dev get-credentials
      
      # package app for VSI deployment
      apt-get update && apt-get install -y build-essential debhelper fakeroot
      bash terraform/scripts/build.sh
      dpkg-buildpackage -rfakeroot -us -uc -b && mv ../myapplication-0.0_1-1_all.deb terraform/my-application-0.0_1-1_all.deb
      if [ ! -f terraform/my-application-0.0_1-1_all.deb ]; then echo "Debian package was not successfully created."; exit 1; fi
    docker_image: maven:3-jdk-8
- name: Terraform Plan Stage
  inputs:
  - type: job
    stage: Build Stage
    job: Build
  triggers:
  - type: stage
  jobs:
  - name: Plan
    type: builder
    working_dir: terraform
    artifact_dir: ''
    build_type: customimage
    script: |-
      #!/bin/bash
      set -eo pipefail
      export PUBLIC_KEY=$(cat publickey.txt)
      export TF_VAR_ibm_sl_api_key=$(cat slkey.txt)
      export TF_VAR_ibm_sl_username=$(cat slusername.txt)
      export TF_VAR_ibm_cloud_api_key=$(cat cloudkey.txt)
      export VI_INSTANCE_NAME=$(cat instancename.txt)
      if [ -f gituser.txt ]; then export GIT_USER=$(cat gituser.txt); fi
      if [ -f gitpassword.txt ]; then export GIT_PASSWORD=$(cat gitpassword.txt); fi
      export GIT_URL=$(cat giturl.txt)
      bash scripts/fetch-state.sh
      terraform init -input=false
      terraform validate
      terraform plan -var "ssh_public_key=$PUBLIC_KEY" -input=false -out tfplan
    docker_image: ibmterraform/terraform-provider-ibm-docker
- name: Terraform Apply Stage
  inputs:
  - type: job
    stage: Terraform Plan Stage
    job: Plan
  triggers:
  - type: stage
  jobs:
  - name: Apply
    type: builder
    artifact_dir: ''
    build_type: customimage
    script: |-
      #!/bin/bash
      set -eo pipefail
      terraform apply -auto-approve -input=false tfplan
      terraform output "host ip" > hostip.txt
      bash scripts/publish-state.sh
    docker_image: ibmterraform/terraform-provider-ibm-docker
- name: Deploy / Install / Start Stage
  inputs:
  - type: job
    stage: Terraform Apply Stage
    job: Apply
  triggers:
  - type: stage
  jobs:
  - name: Deploy
    type: builder
    artifact_dir: ''
    build_type: customimage
    script: |-
      #!/bin/sh
      set -eo pipefail
      apk add --no-cache openssh rsync
      VSI_HOST=$(cat hostip.txt)
      ssh -o StrictHostKeyChecking=no -i ssh_private_key root@$VSI_HOST "apt-get update; apt-get install rsync; mkdir -p app"
      rsync -arv -e "ssh -i ssh_private_key" my-application-0.0_1-1_all.deb root@$VSI_HOST:app
    docker_image: alpine
  - name: Install
    type: builder
    artifact_dir: ''
    build_type: shell
    script: |-
      #!/bin/bash
      set -eo pipefail
      VSI_HOST=$(cat hostip.txt)
      ssh -o StrictHostKeyChecking=no -i ssh_private_key root@$VSI_HOST "rm -rf /usr/src/my-application; cd app; dpkg -i my-application-0.0_1-1_all.deb; cd /usr/src/my-application; source install.sh"
  - name: Start
    type: builder
    artifact_dir: ''
    build_type: shell
    script: |-
      #!/bin/bash
      set -eo pipefail
      VSI_HOST=$(cat hostip.txt)
      ssh -o StrictHostKeyChecking=no -i ssh_private_key root@$VSI_HOST "cd /usr/src/my-application; nohup bash start.sh &> output.log &"
      ssh -o StrictHostKeyChecking=no -i ssh_private_key root@$VSI_HOST "cd /usr/src/my-application; cat output.log"
- name: Health Check Stage
  inputs:
  - type: job
    stage: Deploy / Install / Start Stage
    job: Start
  triggers:
  - type: stage
  jobs:
  - name: Test
    type: tester
    script: |
      #!/bin/sh
      set -eo pipefail
      apk add --no-cache curl openssh
      VSI_HOST=$(cat hostip.txt)
      PORT='3000'
      if [ $(curl -sL -w "%{http_code}\\n" "http://${VSI_HOST}:${PORT}/health" -o /dev/null --connect-timeout 3 --max-time 5 --retry 3 --retry-max-time 30) == "200" ]; then
        echo "Successfully reached health endpoint: http://${VSI_HOST}:${PORT}/health"
        echo "====================================================================="
        ssh -o StrictHostKeyChecking=no -i ssh_private_key root@$VSI_HOST "cd /usr/src/my-application; sed -i 's/localhost/${VSI_HOST}/g' output.log; sed -i 's/0.0.0.0/${VSI_HOST}/g' output.log; sed -i 's/127.0.0.1/${VSI_HOST}/g' output.log; cat output.log"
      else
        echo "Could not reach health endpoint: http://${VSI_HOST}:${PORT}/health"
        exit 1;
      fi;
    test_type: customimage
    docker_image: alpine
hooks:
- enabled: true
  label: null
  ssl_enabled: false
  url: http://lms-api/v1/messaging/webhook/publish
{{/isVSI}}